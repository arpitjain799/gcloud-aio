<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>gcloud.rest.datastore.datastore API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>gcloud.rest.datastore.datastore</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from __future__ import absolute_import
from __future__ import division
from __future__ import print_function
from __future__ import unicode_literals
from builtins import str
import warnings
with warnings.catch_warnings():
    warnings.simplefilter(&#34;ignore&#34;)
    from future import standard_library
standard_library.install_aliases()
from builtins import object
import json
import logging
import os
from typing import Any
from typing import AnyStr
from typing import Dict
from typing import IO
from typing import List
from typing import Optional
from typing import Union

from gcloud.rest.auth import SyncSession  # pylint: disable=no-name-in-module
from gcloud.rest.auth import BUILD_GCLOUD_REST  # pylint: disable=no-name-in-module
from gcloud.rest.auth import Token  # pylint: disable=no-name-in-module
from gcloud.rest.datastore.constants import Consistency
from gcloud.rest.datastore.constants import Mode
from gcloud.rest.datastore.constants import Operation
from gcloud.rest.datastore.datastore_operation import DatastoreOperation
from gcloud.rest.datastore.entity import EntityResult
from gcloud.rest.datastore.key import Key
from gcloud.rest.datastore.mutation import MutationResult
from gcloud.rest.datastore.query import BaseQuery
from gcloud.rest.datastore.query import QueryResultBatch
from gcloud.rest.datastore.value import Value

# Selectively load libraries based on the package
if BUILD_GCLOUD_REST:
    from requests import Session
else:
    from aiohttp import ClientSession as Session  # type: ignore[assignment]


try:
    API_ROOT = &#39;http://{}/v1&#39;.format((os.environ[&#34;DATASTORE_EMULATOR_HOST&#34;]))
    IS_DEV = True
except KeyError:
    API_ROOT = &#39;https://datastore.googleapis.com/v1&#39;
    IS_DEV = False

SCOPES = [
    &#39;https://www.googleapis.com/auth/cloud-platform&#39;,
    &#39;https://www.googleapis.com/auth/datastore&#39;,
]

log = logging.getLogger(__name__)


class Datastore(object):
    datastore_operation_kind = DatastoreOperation
    entity_result_kind = EntityResult
    key_kind = Key
    mutation_result_kind = MutationResult
    query_result_batch_kind = QueryResultBatch
    value_kind = Value

    #_project: Optional[str]

    def __init__(self, project                = None,
                 service_file                                   = None,
                 namespace      = &#39;&#39;, session                    = None,
                 token                  = None)        :
        self.namespace = namespace
        self.session = SyncSession(session)

        if IS_DEV:
            self._project = (os.environ.get(&#39;DATASTORE_PROJECT_ID&#39;)
                             or os.environ.get(&#39;GOOGLE_CLOUD_PROJECT&#39;)
                             or &#39;dev&#39;)
            # Tokens are not needed when using dev emulator
            self.token = None
        else:
            self._project = project
            self.token = token or Token(
                service_file=service_file, scopes=SCOPES,
                session=self.session.session)  # type: ignore[arg-type]

    def project(self)       :
        if self._project:
            return self._project

        if IS_DEV or self.token is None:
            raise Exception(&#39;project can not be determined in dev mode&#39;)

        self._project = self.token.get_project()
        if self._project:
            return self._project

        raise Exception(&#39;could not determine project, please set it manually&#39;)

    @staticmethod
    def _make_commit_body(mutations                      ,
                          transaction                = None,
                          mode       = Mode.TRANSACTIONAL)                  :
        if not mutations:
            raise Exception(&#39;at least one mutation record is required&#39;)

        if transaction is None and mode != Mode.NON_TRANSACTIONAL:
            raise Exception(&#39;a transaction ID must be provided when mode is &#39;
                            &#39;transactional&#39;)

        data = {
            &#39;mode&#39;: mode.value,
            &#39;mutations&#39;: mutations,
        }
        if transaction is not None:
            data[&#39;transaction&#39;] = transaction
        return data

    def headers(self)                  :
        if IS_DEV or self.token is None:
            return {}

        token = self.token.get()
        return {
            &#39;Authorization&#39;: &#39;Bearer {}&#39;.format((token)),
        }

    # TODO: support mutations w version specifiers, return new version (commit)
    @classmethod
    def make_mutation(
            cls, operation           , key     ,
            properties                           = None)                  :
        if operation == Operation.DELETE:
            return {operation.value: key.to_repr()}

        mutation_properties = {}
        for k, v in (properties or {}).items():
            value = v if isinstance(v, cls.value_kind) else cls.value_kind(v)
            mutation_properties[k] = value.to_repr()

        return {
            operation.value: {
                &#39;key&#39;: key.to_repr(),
                &#39;properties&#39;: mutation_properties,
            }
        }

    # https://cloud.google.com/datastore/docs/reference/data/rest/v1/projects/allocateIds
    def allocateIds(self, keys           ,
                          session                    = None,
                          timeout      = 10)             :
        project = self.project()
        url = &#39;{}/projects/{}:allocateIds&#39;.format((API_ROOT), (project))

        payload = json.dumps({
            &#39;keys&#39;: [k.to_repr() for k in keys],
        }).encode(&#39;utf-8&#39;)

        headers = self.headers()
        headers.update({
            &#39;Content-Length&#39;: str(len(payload)),
            &#39;Content-Type&#39;: &#39;application/json&#39;,
        })

        s = SyncSession(session) if session else self.session
        # TODO: the type issue will be fixed in auth-4.0.2
        resp = s.post(url, data=payload,  # type: ignore[arg-type]
                            headers=headers, timeout=timeout)
        data = resp.json()

        return [self.key_kind.from_repr(k) for k in data[&#39;keys&#39;]]

    # https://cloud.google.com/datastore/docs/reference/data/rest/v1/projects/beginTransaction
    # TODO: support readwrite vs readonly transaction types
    def beginTransaction(self, session                    = None,
                               timeout      = 10)       :
        project = self.project()
        url = &#39;{}/projects/{}:beginTransaction&#39;.format((API_ROOT), (project))
        headers = self.headers()
        headers.update({
            &#39;Content-Length&#39;: &#39;0&#39;,
            &#39;Content-Type&#39;: &#39;application/json&#39;,
        })

        s = SyncSession(session) if session else self.session
        resp = s.post(url, headers=headers, timeout=timeout)
        data = resp.json()

        transaction      = data[&#39;transaction&#39;]
        return transaction

    # https://cloud.google.com/datastore/docs/reference/data/rest/v1/projects/commit
    def commit(self, mutations                      ,
                     transaction                = None,
                     mode       = Mode.TRANSACTIONAL,
                     session                    = None,
                     timeout      = 10)                  :
        project = self.project()
        url = &#39;{}/projects/{}:commit&#39;.format((API_ROOT), (project))

        body = self._make_commit_body(mutations, transaction=transaction,
                                      mode=mode)
        payload = json.dumps(body).encode(&#39;utf-8&#39;)

        headers = self.headers()
        headers.update({
            &#39;Content-Length&#39;: str(len(payload)),
            &#39;Content-Type&#39;: &#39;application/json&#39;,
        })

        s = SyncSession(session) if session else self.session
        # TODO: the type issue will be fixed in auth-4.0.2
        resp = s.post(url, data=payload,  # type: ignore[arg-type]
                            headers=headers, timeout=timeout)
        data                 = resp.json()

        return {
            &#39;mutationResults&#39;: [self.mutation_result_kind.from_repr(r)
                                for r in data.get(&#39;mutationResults&#39;, [])],
            &#39;indexUpdates&#39;: data.get(&#39;indexUpdates&#39;, 0),
        }

    # https://cloud.google.com/datastore/docs/reference/admin/rest/v1/projects/export
    def export(self, output_bucket_prefix     ,
                     kinds                      = None,
                     namespaces                      = None,
                     labels                           = None,
                     session                    = None,
                     timeout      = 10)                      :
        project = self.project()
        url = &#39;{}/projects/{}:export&#39;.format((API_ROOT), (project))

        payload = json.dumps({
            &#39;entityFilter&#39;: {
                &#39;kinds&#39;: kinds or [],
                &#39;namespaceIds&#39;: namespaces or [],
            },
            &#39;labels&#39;: labels or {},
            &#39;outputUrlPrefix&#39;: &#39;gs://{}&#39;.format((output_bucket_prefix)),
        }).encode(&#39;utf-8&#39;)

        headers = self.headers()
        headers.update({
            &#39;Content-Length&#39;: str(len(payload)),
            &#39;Content-Type&#39;: &#39;application/json&#39;,
        })

        s = SyncSession(session) if session else self.session
        # TODO: the type issue will be fixed in auth-4.0.2
        resp = s.post(url, data=payload,  # type: ignore[arg-type]
                            headers=headers, timeout=timeout)
        data                 = resp.json()

        return self.datastore_operation_kind.from_repr(data)

    # https://cloud.google.com/datastore/docs/reference/data/rest/v1/projects.operations/get
    def get_datastore_operation(self, name     ,
                                      session                    = None,
                                      timeout      = 10)                      :
        url = &#39;{}/{}&#39;.format((API_ROOT), (name))

        headers = self.headers()
        headers.update({
            &#39;Content-Type&#39;: &#39;application/json&#39;,
        })

        s = SyncSession(session) if session else self.session
        resp = s.get(url, headers=headers, timeout=timeout)
        data                 = resp.json()

        return self.datastore_operation_kind.from_repr(data)

    # https://cloud.google.com/datastore/docs/reference/data/rest/v1/projects/lookup
    def lookup(
            self, keys           , transaction                = None,
            consistency              = Consistency.STRONG,
            session                    = None, timeout      = 10
    )                                             :
        project = self.project()
        url = &#39;{}/projects/{}:lookup&#39;.format((API_ROOT), (project))

        if transaction:
            options = {&#39;transaction&#39;: transaction}
        else:
            options = {&#39;readConsistency&#39;: consistency.value}
        payload = json.dumps({
            &#39;keys&#39;: [k.to_repr() for k in keys],
            &#39;readOptions&#39;: options,
        }).encode(&#39;utf-8&#39;)

        headers = self.headers()
        headers.update({
            &#39;Content-Length&#39;: str(len(payload)),
            &#39;Content-Type&#39;: &#39;application/json&#39;,
        })

        s = SyncSession(session) if session else self.session
        # TODO: the type issue will be fixed in auth-4.0.2
        resp = s.post(url, data=payload,  # type: ignore[arg-type]
                            headers=headers, timeout=timeout)

        data                       = resp.json()

        return {
            &#39;found&#39;: [self.entity_result_kind.from_repr(e)
                      for e in data.get(&#39;found&#39;, [])],
            &#39;missing&#39;: [self.entity_result_kind.from_repr(e)
                        for e in data.get(&#39;missing&#39;, [])],
            &#39;deferred&#39;: [self.key_kind.from_repr(k)
                         for k in data.get(&#39;deferred&#39;, [])],
        }

    # https://cloud.google.com/datastore/docs/reference/data/rest/v1/projects/reserveIds
    def reserveIds(self, keys           , database_id      = &#39;&#39;,
                         session                    = None,
                         timeout      = 10)        :
        project = self.project()
        url = &#39;{}/projects/{}:reserveIds&#39;.format((API_ROOT), (project))

        payload = json.dumps({
            &#39;databaseId&#39;: database_id,
            &#39;keys&#39;: [k.to_repr() for k in keys],
        }).encode(&#39;utf-8&#39;)

        headers = self.headers()
        headers.update({
            &#39;Content-Length&#39;: str(len(payload)),
            &#39;Content-Type&#39;: &#39;application/json&#39;,
        })

        s = SyncSession(session) if session else self.session
        # TODO: the type issue will be fixed in auth-4.0.2
        s.post(url, data=payload,  # type: ignore[arg-type]
                     headers=headers, timeout=timeout)

    # https://cloud.google.com/datastore/docs/reference/data/rest/v1/projects/rollback
    def rollback(self, transaction     ,
                       session                    = None,
                       timeout      = 10)        :
        project = self.project()
        url = &#39;{}/projects/{}:rollback&#39;.format((API_ROOT), (project))

        payload = json.dumps({
            &#39;transaction&#39;: transaction,
        }).encode(&#39;utf-8&#39;)

        headers = self.headers()
        headers.update({
            &#39;Content-Length&#39;: str(len(payload)),
            &#39;Content-Type&#39;: &#39;application/json&#39;,
        })

        s = SyncSession(session) if session else self.session
        # TODO: the type issue will be fixed in auth-4.0.2
        s.post(url, data=payload,  # type: ignore[arg-type]
                     headers=headers, timeout=timeout)

    # https://cloud.google.com/datastore/docs/reference/data/rest/v1/projects/runQuery
    def runQuery(self, query           ,
                       transaction                = None,
                       consistency              = Consistency.EVENTUAL,
                       session                    = None,
                       timeout      = 10)                    :
        project = self.project()
        url = &#39;{}/projects/{}:runQuery&#39;.format((API_ROOT), (project))

        if transaction:
            options = {&#39;transaction&#39;: transaction}
        else:
            options = {&#39;readConsistency&#39;: consistency.value}
        payload = json.dumps({
            &#39;partitionId&#39;: {
                &#39;projectId&#39;: project,
                &#39;namespaceId&#39;: self.namespace,
            },
            query.json_key: query.to_repr(),
            &#39;readOptions&#39;: options,
        }).encode(&#39;utf-8&#39;)

        headers = self.headers()
        headers.update({
            &#39;Content-Length&#39;: str(len(payload)),
            &#39;Content-Type&#39;: &#39;application/json&#39;,
        })

        s = SyncSession(session) if session else self.session
        # TODO: the type issue will be fixed in auth-4.0.2
        resp = s.post(url, data=payload,  # type: ignore[arg-type]
                            headers=headers, timeout=timeout)

        data                 = resp.json()
        return self.query_result_batch_kind.from_repr(data[&#39;batch&#39;])

    def delete(self, key     ,
                     session                    = None)                  :
        return self.operate(Operation.DELETE, key, session=session)

    def insert(self, key     , properties                ,
                     session                    = None)                  :
        return self.operate(Operation.INSERT, key, properties,
                                  session=session)

    def update(self, key     , properties                ,
                     session                    = None)                  :
        return self.operate(Operation.UPDATE, key, properties,
                                  session=session)

    def upsert(self, key     , properties                ,
                     session                    = None)                  :
        return self.operate(Operation.UPSERT, key, properties,
                                  session=session)

    # TODO: accept Entity rather than key/properties?
    def operate(self, operation           , key     ,
                      properties                           = None,
                      session                    = None)                  :
        transaction = self.beginTransaction(session=session)
        mutation = self.make_mutation(operation, key, properties=properties)
        return self.commit([mutation], transaction=transaction,
                                 session=session)

    def close(self)        :
        self.session.close()

    def __enter__(self)               :
        return self

    def __exit__(self, *args     )        :
        self.close()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="gcloud.rest.datastore.datastore.Datastore"><code class="flex name class">
<span>class <span class="ident">Datastore</span></span>
<span>(</span><span>project=None, service_file=None, namespace='', session=None, token=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Datastore(object):
    datastore_operation_kind = DatastoreOperation
    entity_result_kind = EntityResult
    key_kind = Key
    mutation_result_kind = MutationResult
    query_result_batch_kind = QueryResultBatch
    value_kind = Value

    #_project: Optional[str]

    def __init__(self, project                = None,
                 service_file                                   = None,
                 namespace      = &#39;&#39;, session                    = None,
                 token                  = None)        :
        self.namespace = namespace
        self.session = SyncSession(session)

        if IS_DEV:
            self._project = (os.environ.get(&#39;DATASTORE_PROJECT_ID&#39;)
                             or os.environ.get(&#39;GOOGLE_CLOUD_PROJECT&#39;)
                             or &#39;dev&#39;)
            # Tokens are not needed when using dev emulator
            self.token = None
        else:
            self._project = project
            self.token = token or Token(
                service_file=service_file, scopes=SCOPES,
                session=self.session.session)  # type: ignore[arg-type]

    def project(self)       :
        if self._project:
            return self._project

        if IS_DEV or self.token is None:
            raise Exception(&#39;project can not be determined in dev mode&#39;)

        self._project = self.token.get_project()
        if self._project:
            return self._project

        raise Exception(&#39;could not determine project, please set it manually&#39;)

    @staticmethod
    def _make_commit_body(mutations                      ,
                          transaction                = None,
                          mode       = Mode.TRANSACTIONAL)                  :
        if not mutations:
            raise Exception(&#39;at least one mutation record is required&#39;)

        if transaction is None and mode != Mode.NON_TRANSACTIONAL:
            raise Exception(&#39;a transaction ID must be provided when mode is &#39;
                            &#39;transactional&#39;)

        data = {
            &#39;mode&#39;: mode.value,
            &#39;mutations&#39;: mutations,
        }
        if transaction is not None:
            data[&#39;transaction&#39;] = transaction
        return data

    def headers(self)                  :
        if IS_DEV or self.token is None:
            return {}

        token = self.token.get()
        return {
            &#39;Authorization&#39;: &#39;Bearer {}&#39;.format((token)),
        }

    # TODO: support mutations w version specifiers, return new version (commit)
    @classmethod
    def make_mutation(
            cls, operation           , key     ,
            properties                           = None)                  :
        if operation == Operation.DELETE:
            return {operation.value: key.to_repr()}

        mutation_properties = {}
        for k, v in (properties or {}).items():
            value = v if isinstance(v, cls.value_kind) else cls.value_kind(v)
            mutation_properties[k] = value.to_repr()

        return {
            operation.value: {
                &#39;key&#39;: key.to_repr(),
                &#39;properties&#39;: mutation_properties,
            }
        }

    # https://cloud.google.com/datastore/docs/reference/data/rest/v1/projects/allocateIds
    def allocateIds(self, keys           ,
                          session                    = None,
                          timeout      = 10)             :
        project = self.project()
        url = &#39;{}/projects/{}:allocateIds&#39;.format((API_ROOT), (project))

        payload = json.dumps({
            &#39;keys&#39;: [k.to_repr() for k in keys],
        }).encode(&#39;utf-8&#39;)

        headers = self.headers()
        headers.update({
            &#39;Content-Length&#39;: str(len(payload)),
            &#39;Content-Type&#39;: &#39;application/json&#39;,
        })

        s = SyncSession(session) if session else self.session
        # TODO: the type issue will be fixed in auth-4.0.2
        resp = s.post(url, data=payload,  # type: ignore[arg-type]
                            headers=headers, timeout=timeout)
        data = resp.json()

        return [self.key_kind.from_repr(k) for k in data[&#39;keys&#39;]]

    # https://cloud.google.com/datastore/docs/reference/data/rest/v1/projects/beginTransaction
    # TODO: support readwrite vs readonly transaction types
    def beginTransaction(self, session                    = None,
                               timeout      = 10)       :
        project = self.project()
        url = &#39;{}/projects/{}:beginTransaction&#39;.format((API_ROOT), (project))
        headers = self.headers()
        headers.update({
            &#39;Content-Length&#39;: &#39;0&#39;,
            &#39;Content-Type&#39;: &#39;application/json&#39;,
        })

        s = SyncSession(session) if session else self.session
        resp = s.post(url, headers=headers, timeout=timeout)
        data = resp.json()

        transaction      = data[&#39;transaction&#39;]
        return transaction

    # https://cloud.google.com/datastore/docs/reference/data/rest/v1/projects/commit
    def commit(self, mutations                      ,
                     transaction                = None,
                     mode       = Mode.TRANSACTIONAL,
                     session                    = None,
                     timeout      = 10)                  :
        project = self.project()
        url = &#39;{}/projects/{}:commit&#39;.format((API_ROOT), (project))

        body = self._make_commit_body(mutations, transaction=transaction,
                                      mode=mode)
        payload = json.dumps(body).encode(&#39;utf-8&#39;)

        headers = self.headers()
        headers.update({
            &#39;Content-Length&#39;: str(len(payload)),
            &#39;Content-Type&#39;: &#39;application/json&#39;,
        })

        s = SyncSession(session) if session else self.session
        # TODO: the type issue will be fixed in auth-4.0.2
        resp = s.post(url, data=payload,  # type: ignore[arg-type]
                            headers=headers, timeout=timeout)
        data                 = resp.json()

        return {
            &#39;mutationResults&#39;: [self.mutation_result_kind.from_repr(r)
                                for r in data.get(&#39;mutationResults&#39;, [])],
            &#39;indexUpdates&#39;: data.get(&#39;indexUpdates&#39;, 0),
        }

    # https://cloud.google.com/datastore/docs/reference/admin/rest/v1/projects/export
    def export(self, output_bucket_prefix     ,
                     kinds                      = None,
                     namespaces                      = None,
                     labels                           = None,
                     session                    = None,
                     timeout      = 10)                      :
        project = self.project()
        url = &#39;{}/projects/{}:export&#39;.format((API_ROOT), (project))

        payload = json.dumps({
            &#39;entityFilter&#39;: {
                &#39;kinds&#39;: kinds or [],
                &#39;namespaceIds&#39;: namespaces or [],
            },
            &#39;labels&#39;: labels or {},
            &#39;outputUrlPrefix&#39;: &#39;gs://{}&#39;.format((output_bucket_prefix)),
        }).encode(&#39;utf-8&#39;)

        headers = self.headers()
        headers.update({
            &#39;Content-Length&#39;: str(len(payload)),
            &#39;Content-Type&#39;: &#39;application/json&#39;,
        })

        s = SyncSession(session) if session else self.session
        # TODO: the type issue will be fixed in auth-4.0.2
        resp = s.post(url, data=payload,  # type: ignore[arg-type]
                            headers=headers, timeout=timeout)
        data                 = resp.json()

        return self.datastore_operation_kind.from_repr(data)

    # https://cloud.google.com/datastore/docs/reference/data/rest/v1/projects.operations/get
    def get_datastore_operation(self, name     ,
                                      session                    = None,
                                      timeout      = 10)                      :
        url = &#39;{}/{}&#39;.format((API_ROOT), (name))

        headers = self.headers()
        headers.update({
            &#39;Content-Type&#39;: &#39;application/json&#39;,
        })

        s = SyncSession(session) if session else self.session
        resp = s.get(url, headers=headers, timeout=timeout)
        data                 = resp.json()

        return self.datastore_operation_kind.from_repr(data)

    # https://cloud.google.com/datastore/docs/reference/data/rest/v1/projects/lookup
    def lookup(
            self, keys           , transaction                = None,
            consistency              = Consistency.STRONG,
            session                    = None, timeout      = 10
    )                                             :
        project = self.project()
        url = &#39;{}/projects/{}:lookup&#39;.format((API_ROOT), (project))

        if transaction:
            options = {&#39;transaction&#39;: transaction}
        else:
            options = {&#39;readConsistency&#39;: consistency.value}
        payload = json.dumps({
            &#39;keys&#39;: [k.to_repr() for k in keys],
            &#39;readOptions&#39;: options,
        }).encode(&#39;utf-8&#39;)

        headers = self.headers()
        headers.update({
            &#39;Content-Length&#39;: str(len(payload)),
            &#39;Content-Type&#39;: &#39;application/json&#39;,
        })

        s = SyncSession(session) if session else self.session
        # TODO: the type issue will be fixed in auth-4.0.2
        resp = s.post(url, data=payload,  # type: ignore[arg-type]
                            headers=headers, timeout=timeout)

        data                       = resp.json()

        return {
            &#39;found&#39;: [self.entity_result_kind.from_repr(e)
                      for e in data.get(&#39;found&#39;, [])],
            &#39;missing&#39;: [self.entity_result_kind.from_repr(e)
                        for e in data.get(&#39;missing&#39;, [])],
            &#39;deferred&#39;: [self.key_kind.from_repr(k)
                         for k in data.get(&#39;deferred&#39;, [])],
        }

    # https://cloud.google.com/datastore/docs/reference/data/rest/v1/projects/reserveIds
    def reserveIds(self, keys           , database_id      = &#39;&#39;,
                         session                    = None,
                         timeout      = 10)        :
        project = self.project()
        url = &#39;{}/projects/{}:reserveIds&#39;.format((API_ROOT), (project))

        payload = json.dumps({
            &#39;databaseId&#39;: database_id,
            &#39;keys&#39;: [k.to_repr() for k in keys],
        }).encode(&#39;utf-8&#39;)

        headers = self.headers()
        headers.update({
            &#39;Content-Length&#39;: str(len(payload)),
            &#39;Content-Type&#39;: &#39;application/json&#39;,
        })

        s = SyncSession(session) if session else self.session
        # TODO: the type issue will be fixed in auth-4.0.2
        s.post(url, data=payload,  # type: ignore[arg-type]
                     headers=headers, timeout=timeout)

    # https://cloud.google.com/datastore/docs/reference/data/rest/v1/projects/rollback
    def rollback(self, transaction     ,
                       session                    = None,
                       timeout      = 10)        :
        project = self.project()
        url = &#39;{}/projects/{}:rollback&#39;.format((API_ROOT), (project))

        payload = json.dumps({
            &#39;transaction&#39;: transaction,
        }).encode(&#39;utf-8&#39;)

        headers = self.headers()
        headers.update({
            &#39;Content-Length&#39;: str(len(payload)),
            &#39;Content-Type&#39;: &#39;application/json&#39;,
        })

        s = SyncSession(session) if session else self.session
        # TODO: the type issue will be fixed in auth-4.0.2
        s.post(url, data=payload,  # type: ignore[arg-type]
                     headers=headers, timeout=timeout)

    # https://cloud.google.com/datastore/docs/reference/data/rest/v1/projects/runQuery
    def runQuery(self, query           ,
                       transaction                = None,
                       consistency              = Consistency.EVENTUAL,
                       session                    = None,
                       timeout      = 10)                    :
        project = self.project()
        url = &#39;{}/projects/{}:runQuery&#39;.format((API_ROOT), (project))

        if transaction:
            options = {&#39;transaction&#39;: transaction}
        else:
            options = {&#39;readConsistency&#39;: consistency.value}
        payload = json.dumps({
            &#39;partitionId&#39;: {
                &#39;projectId&#39;: project,
                &#39;namespaceId&#39;: self.namespace,
            },
            query.json_key: query.to_repr(),
            &#39;readOptions&#39;: options,
        }).encode(&#39;utf-8&#39;)

        headers = self.headers()
        headers.update({
            &#39;Content-Length&#39;: str(len(payload)),
            &#39;Content-Type&#39;: &#39;application/json&#39;,
        })

        s = SyncSession(session) if session else self.session
        # TODO: the type issue will be fixed in auth-4.0.2
        resp = s.post(url, data=payload,  # type: ignore[arg-type]
                            headers=headers, timeout=timeout)

        data                 = resp.json()
        return self.query_result_batch_kind.from_repr(data[&#39;batch&#39;])

    def delete(self, key     ,
                     session                    = None)                  :
        return self.operate(Operation.DELETE, key, session=session)

    def insert(self, key     , properties                ,
                     session                    = None)                  :
        return self.operate(Operation.INSERT, key, properties,
                                  session=session)

    def update(self, key     , properties                ,
                     session                    = None)                  :
        return self.operate(Operation.UPDATE, key, properties,
                                  session=session)

    def upsert(self, key     , properties                ,
                     session                    = None)                  :
        return self.operate(Operation.UPSERT, key, properties,
                                  session=session)

    # TODO: accept Entity rather than key/properties?
    def operate(self, operation           , key     ,
                      properties                           = None,
                      session                    = None)                  :
        transaction = self.beginTransaction(session=session)
        mutation = self.make_mutation(operation, key, properties=properties)
        return self.commit([mutation], transaction=transaction,
                                 session=session)

    def close(self)        :
        self.session.close()

    def __enter__(self)               :
        return self

    def __exit__(self, *args     )        :
        self.close()</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="gcloud.rest.datastore.datastore.Datastore.datastore_operation_kind"><code class="name">var <span class="ident">datastore_operation_kind</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="gcloud.rest.datastore.datastore.Datastore.entity_result_kind"><code class="name">var <span class="ident">entity_result_kind</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="gcloud.rest.datastore.datastore.Datastore.key_kind"><code class="name">var <span class="ident">key_kind</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="gcloud.rest.datastore.datastore.Datastore.mutation_result_kind"><code class="name">var <span class="ident">mutation_result_kind</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="gcloud.rest.datastore.datastore.Datastore.query_result_batch_kind"><code class="name">var <span class="ident">query_result_batch_kind</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="gcloud.rest.datastore.datastore.Datastore.value_kind"><code class="name">var <span class="ident">value_kind</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="gcloud.rest.datastore.datastore.Datastore.make_mutation"><code class="name flex">
<span>def <span class="ident">make_mutation</span></span>(<span>operation, key, properties=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def make_mutation(
        cls, operation           , key     ,
        properties                           = None)                  :
    if operation == Operation.DELETE:
        return {operation.value: key.to_repr()}

    mutation_properties = {}
    for k, v in (properties or {}).items():
        value = v if isinstance(v, cls.value_kind) else cls.value_kind(v)
        mutation_properties[k] = value.to_repr()

    return {
        operation.value: {
            &#39;key&#39;: key.to_repr(),
            &#39;properties&#39;: mutation_properties,
        }
    }</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="gcloud.rest.datastore.datastore.Datastore.allocateIds"><code class="name flex">
<span>def <span class="ident">allocateIds</span></span>(<span>self, keys, session=None, timeout=10)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def allocateIds(self, keys           ,
                      session                    = None,
                      timeout      = 10)             :
    project = self.project()
    url = &#39;{}/projects/{}:allocateIds&#39;.format((API_ROOT), (project))

    payload = json.dumps({
        &#39;keys&#39;: [k.to_repr() for k in keys],
    }).encode(&#39;utf-8&#39;)

    headers = self.headers()
    headers.update({
        &#39;Content-Length&#39;: str(len(payload)),
        &#39;Content-Type&#39;: &#39;application/json&#39;,
    })

    s = SyncSession(session) if session else self.session
    # TODO: the type issue will be fixed in auth-4.0.2
    resp = s.post(url, data=payload,  # type: ignore[arg-type]
                        headers=headers, timeout=timeout)
    data = resp.json()

    return [self.key_kind.from_repr(k) for k in data[&#39;keys&#39;]]</code></pre>
</details>
</dd>
<dt id="gcloud.rest.datastore.datastore.Datastore.beginTransaction"><code class="name flex">
<span>def <span class="ident">beginTransaction</span></span>(<span>self, session=None, timeout=10)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def beginTransaction(self, session                    = None,
                           timeout      = 10)       :
    project = self.project()
    url = &#39;{}/projects/{}:beginTransaction&#39;.format((API_ROOT), (project))
    headers = self.headers()
    headers.update({
        &#39;Content-Length&#39;: &#39;0&#39;,
        &#39;Content-Type&#39;: &#39;application/json&#39;,
    })

    s = SyncSession(session) if session else self.session
    resp = s.post(url, headers=headers, timeout=timeout)
    data = resp.json()

    transaction      = data[&#39;transaction&#39;]
    return transaction</code></pre>
</details>
</dd>
<dt id="gcloud.rest.datastore.datastore.Datastore.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self)        :
    self.session.close()</code></pre>
</details>
</dd>
<dt id="gcloud.rest.datastore.datastore.Datastore.commit"><code class="name flex">
<span>def <span class="ident">commit</span></span>(<span>self, mutations, transaction=None, mode=Mode.TRANSACTIONAL, session=None, timeout=10)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def commit(self, mutations                      ,
                 transaction                = None,
                 mode       = Mode.TRANSACTIONAL,
                 session                    = None,
                 timeout      = 10)                  :
    project = self.project()
    url = &#39;{}/projects/{}:commit&#39;.format((API_ROOT), (project))

    body = self._make_commit_body(mutations, transaction=transaction,
                                  mode=mode)
    payload = json.dumps(body).encode(&#39;utf-8&#39;)

    headers = self.headers()
    headers.update({
        &#39;Content-Length&#39;: str(len(payload)),
        &#39;Content-Type&#39;: &#39;application/json&#39;,
    })

    s = SyncSession(session) if session else self.session
    # TODO: the type issue will be fixed in auth-4.0.2
    resp = s.post(url, data=payload,  # type: ignore[arg-type]
                        headers=headers, timeout=timeout)
    data                 = resp.json()

    return {
        &#39;mutationResults&#39;: [self.mutation_result_kind.from_repr(r)
                            for r in data.get(&#39;mutationResults&#39;, [])],
        &#39;indexUpdates&#39;: data.get(&#39;indexUpdates&#39;, 0),
    }</code></pre>
</details>
</dd>
<dt id="gcloud.rest.datastore.datastore.Datastore.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>self, key, session=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete(self, key     ,
                 session                    = None)                  :
    return self.operate(Operation.DELETE, key, session=session)</code></pre>
</details>
</dd>
<dt id="gcloud.rest.datastore.datastore.Datastore.export"><code class="name flex">
<span>def <span class="ident">export</span></span>(<span>self, output_bucket_prefix, kinds=None, namespaces=None, labels=None, session=None, timeout=10)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export(self, output_bucket_prefix     ,
                 kinds                      = None,
                 namespaces                      = None,
                 labels                           = None,
                 session                    = None,
                 timeout      = 10)                      :
    project = self.project()
    url = &#39;{}/projects/{}:export&#39;.format((API_ROOT), (project))

    payload = json.dumps({
        &#39;entityFilter&#39;: {
            &#39;kinds&#39;: kinds or [],
            &#39;namespaceIds&#39;: namespaces or [],
        },
        &#39;labels&#39;: labels or {},
        &#39;outputUrlPrefix&#39;: &#39;gs://{}&#39;.format((output_bucket_prefix)),
    }).encode(&#39;utf-8&#39;)

    headers = self.headers()
    headers.update({
        &#39;Content-Length&#39;: str(len(payload)),
        &#39;Content-Type&#39;: &#39;application/json&#39;,
    })

    s = SyncSession(session) if session else self.session
    # TODO: the type issue will be fixed in auth-4.0.2
    resp = s.post(url, data=payload,  # type: ignore[arg-type]
                        headers=headers, timeout=timeout)
    data                 = resp.json()

    return self.datastore_operation_kind.from_repr(data)</code></pre>
</details>
</dd>
<dt id="gcloud.rest.datastore.datastore.Datastore.get_datastore_operation"><code class="name flex">
<span>def <span class="ident">get_datastore_operation</span></span>(<span>self, name, session=None, timeout=10)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_datastore_operation(self, name     ,
                                  session                    = None,
                                  timeout      = 10)                      :
    url = &#39;{}/{}&#39;.format((API_ROOT), (name))

    headers = self.headers()
    headers.update({
        &#39;Content-Type&#39;: &#39;application/json&#39;,
    })

    s = SyncSession(session) if session else self.session
    resp = s.get(url, headers=headers, timeout=timeout)
    data                 = resp.json()

    return self.datastore_operation_kind.from_repr(data)</code></pre>
</details>
</dd>
<dt id="gcloud.rest.datastore.datastore.Datastore.headers"><code class="name flex">
<span>def <span class="ident">headers</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def headers(self)                  :
    if IS_DEV or self.token is None:
        return {}

    token = self.token.get()
    return {
        &#39;Authorization&#39;: &#39;Bearer {}&#39;.format((token)),
    }</code></pre>
</details>
</dd>
<dt id="gcloud.rest.datastore.datastore.Datastore.insert"><code class="name flex">
<span>def <span class="ident">insert</span></span>(<span>self, key, properties, session=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def insert(self, key     , properties                ,
                 session                    = None)                  :
    return self.operate(Operation.INSERT, key, properties,
                              session=session)</code></pre>
</details>
</dd>
<dt id="gcloud.rest.datastore.datastore.Datastore.lookup"><code class="name flex">
<span>def <span class="ident">lookup</span></span>(<span>self, keys, transaction=None, consistency=Consistency.STRONG, session=None, timeout=10)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lookup(
        self, keys           , transaction                = None,
        consistency              = Consistency.STRONG,
        session                    = None, timeout      = 10
)                                             :
    project = self.project()
    url = &#39;{}/projects/{}:lookup&#39;.format((API_ROOT), (project))

    if transaction:
        options = {&#39;transaction&#39;: transaction}
    else:
        options = {&#39;readConsistency&#39;: consistency.value}
    payload = json.dumps({
        &#39;keys&#39;: [k.to_repr() for k in keys],
        &#39;readOptions&#39;: options,
    }).encode(&#39;utf-8&#39;)

    headers = self.headers()
    headers.update({
        &#39;Content-Length&#39;: str(len(payload)),
        &#39;Content-Type&#39;: &#39;application/json&#39;,
    })

    s = SyncSession(session) if session else self.session
    # TODO: the type issue will be fixed in auth-4.0.2
    resp = s.post(url, data=payload,  # type: ignore[arg-type]
                        headers=headers, timeout=timeout)

    data                       = resp.json()

    return {
        &#39;found&#39;: [self.entity_result_kind.from_repr(e)
                  for e in data.get(&#39;found&#39;, [])],
        &#39;missing&#39;: [self.entity_result_kind.from_repr(e)
                    for e in data.get(&#39;missing&#39;, [])],
        &#39;deferred&#39;: [self.key_kind.from_repr(k)
                     for k in data.get(&#39;deferred&#39;, [])],
    }</code></pre>
</details>
</dd>
<dt id="gcloud.rest.datastore.datastore.Datastore.operate"><code class="name flex">
<span>def <span class="ident">operate</span></span>(<span>self, operation, key, properties=None, session=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def operate(self, operation           , key     ,
                  properties                           = None,
                  session                    = None)                  :
    transaction = self.beginTransaction(session=session)
    mutation = self.make_mutation(operation, key, properties=properties)
    return self.commit([mutation], transaction=transaction,
                             session=session)</code></pre>
</details>
</dd>
<dt id="gcloud.rest.datastore.datastore.Datastore.project"><code class="name flex">
<span>def <span class="ident">project</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def project(self)       :
    if self._project:
        return self._project

    if IS_DEV or self.token is None:
        raise Exception(&#39;project can not be determined in dev mode&#39;)

    self._project = self.token.get_project()
    if self._project:
        return self._project

    raise Exception(&#39;could not determine project, please set it manually&#39;)</code></pre>
</details>
</dd>
<dt id="gcloud.rest.datastore.datastore.Datastore.reserveIds"><code class="name flex">
<span>def <span class="ident">reserveIds</span></span>(<span>self, keys, database_id='', session=None, timeout=10)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reserveIds(self, keys           , database_id      = &#39;&#39;,
                     session                    = None,
                     timeout      = 10)        :
    project = self.project()
    url = &#39;{}/projects/{}:reserveIds&#39;.format((API_ROOT), (project))

    payload = json.dumps({
        &#39;databaseId&#39;: database_id,
        &#39;keys&#39;: [k.to_repr() for k in keys],
    }).encode(&#39;utf-8&#39;)

    headers = self.headers()
    headers.update({
        &#39;Content-Length&#39;: str(len(payload)),
        &#39;Content-Type&#39;: &#39;application/json&#39;,
    })

    s = SyncSession(session) if session else self.session
    # TODO: the type issue will be fixed in auth-4.0.2
    s.post(url, data=payload,  # type: ignore[arg-type]
                 headers=headers, timeout=timeout)</code></pre>
</details>
</dd>
<dt id="gcloud.rest.datastore.datastore.Datastore.rollback"><code class="name flex">
<span>def <span class="ident">rollback</span></span>(<span>self, transaction, session=None, timeout=10)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rollback(self, transaction     ,
                   session                    = None,
                   timeout      = 10)        :
    project = self.project()
    url = &#39;{}/projects/{}:rollback&#39;.format((API_ROOT), (project))

    payload = json.dumps({
        &#39;transaction&#39;: transaction,
    }).encode(&#39;utf-8&#39;)

    headers = self.headers()
    headers.update({
        &#39;Content-Length&#39;: str(len(payload)),
        &#39;Content-Type&#39;: &#39;application/json&#39;,
    })

    s = SyncSession(session) if session else self.session
    # TODO: the type issue will be fixed in auth-4.0.2
    s.post(url, data=payload,  # type: ignore[arg-type]
                 headers=headers, timeout=timeout)</code></pre>
</details>
</dd>
<dt id="gcloud.rest.datastore.datastore.Datastore.runQuery"><code class="name flex">
<span>def <span class="ident">runQuery</span></span>(<span>self, query, transaction=None, consistency=Consistency.EVENTUAL, session=None, timeout=10)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def runQuery(self, query           ,
                   transaction                = None,
                   consistency              = Consistency.EVENTUAL,
                   session                    = None,
                   timeout      = 10)                    :
    project = self.project()
    url = &#39;{}/projects/{}:runQuery&#39;.format((API_ROOT), (project))

    if transaction:
        options = {&#39;transaction&#39;: transaction}
    else:
        options = {&#39;readConsistency&#39;: consistency.value}
    payload = json.dumps({
        &#39;partitionId&#39;: {
            &#39;projectId&#39;: project,
            &#39;namespaceId&#39;: self.namespace,
        },
        query.json_key: query.to_repr(),
        &#39;readOptions&#39;: options,
    }).encode(&#39;utf-8&#39;)

    headers = self.headers()
    headers.update({
        &#39;Content-Length&#39;: str(len(payload)),
        &#39;Content-Type&#39;: &#39;application/json&#39;,
    })

    s = SyncSession(session) if session else self.session
    # TODO: the type issue will be fixed in auth-4.0.2
    resp = s.post(url, data=payload,  # type: ignore[arg-type]
                        headers=headers, timeout=timeout)

    data                 = resp.json()
    return self.query_result_batch_kind.from_repr(data[&#39;batch&#39;])</code></pre>
</details>
</dd>
<dt id="gcloud.rest.datastore.datastore.Datastore.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, key, properties, session=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self, key     , properties                ,
                 session                    = None)                  :
    return self.operate(Operation.UPDATE, key, properties,
                              session=session)</code></pre>
</details>
</dd>
<dt id="gcloud.rest.datastore.datastore.Datastore.upsert"><code class="name flex">
<span>def <span class="ident">upsert</span></span>(<span>self, key, properties, session=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def upsert(self, key     , properties                ,
                 session                    = None)                  :
    return self.operate(Operation.UPSERT, key, properties,
                              session=session)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="gcloud.rest.datastore" href="index.html">gcloud.rest.datastore</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="gcloud.rest.datastore.datastore.Datastore" href="#gcloud.rest.datastore.datastore.Datastore">Datastore</a></code></h4>
<ul class="">
<li><code><a title="gcloud.rest.datastore.datastore.Datastore.allocateIds" href="#gcloud.rest.datastore.datastore.Datastore.allocateIds">allocateIds</a></code></li>
<li><code><a title="gcloud.rest.datastore.datastore.Datastore.beginTransaction" href="#gcloud.rest.datastore.datastore.Datastore.beginTransaction">beginTransaction</a></code></li>
<li><code><a title="gcloud.rest.datastore.datastore.Datastore.close" href="#gcloud.rest.datastore.datastore.Datastore.close">close</a></code></li>
<li><code><a title="gcloud.rest.datastore.datastore.Datastore.commit" href="#gcloud.rest.datastore.datastore.Datastore.commit">commit</a></code></li>
<li><code><a title="gcloud.rest.datastore.datastore.Datastore.datastore_operation_kind" href="#gcloud.rest.datastore.datastore.Datastore.datastore_operation_kind">datastore_operation_kind</a></code></li>
<li><code><a title="gcloud.rest.datastore.datastore.Datastore.delete" href="#gcloud.rest.datastore.datastore.Datastore.delete">delete</a></code></li>
<li><code><a title="gcloud.rest.datastore.datastore.Datastore.entity_result_kind" href="#gcloud.rest.datastore.datastore.Datastore.entity_result_kind">entity_result_kind</a></code></li>
<li><code><a title="gcloud.rest.datastore.datastore.Datastore.export" href="#gcloud.rest.datastore.datastore.Datastore.export">export</a></code></li>
<li><code><a title="gcloud.rest.datastore.datastore.Datastore.get_datastore_operation" href="#gcloud.rest.datastore.datastore.Datastore.get_datastore_operation">get_datastore_operation</a></code></li>
<li><code><a title="gcloud.rest.datastore.datastore.Datastore.headers" href="#gcloud.rest.datastore.datastore.Datastore.headers">headers</a></code></li>
<li><code><a title="gcloud.rest.datastore.datastore.Datastore.insert" href="#gcloud.rest.datastore.datastore.Datastore.insert">insert</a></code></li>
<li><code><a title="gcloud.rest.datastore.datastore.Datastore.key_kind" href="#gcloud.rest.datastore.datastore.Datastore.key_kind">key_kind</a></code></li>
<li><code><a title="gcloud.rest.datastore.datastore.Datastore.lookup" href="#gcloud.rest.datastore.datastore.Datastore.lookup">lookup</a></code></li>
<li><code><a title="gcloud.rest.datastore.datastore.Datastore.make_mutation" href="#gcloud.rest.datastore.datastore.Datastore.make_mutation">make_mutation</a></code></li>
<li><code><a title="gcloud.rest.datastore.datastore.Datastore.mutation_result_kind" href="#gcloud.rest.datastore.datastore.Datastore.mutation_result_kind">mutation_result_kind</a></code></li>
<li><code><a title="gcloud.rest.datastore.datastore.Datastore.operate" href="#gcloud.rest.datastore.datastore.Datastore.operate">operate</a></code></li>
<li><code><a title="gcloud.rest.datastore.datastore.Datastore.project" href="#gcloud.rest.datastore.datastore.Datastore.project">project</a></code></li>
<li><code><a title="gcloud.rest.datastore.datastore.Datastore.query_result_batch_kind" href="#gcloud.rest.datastore.datastore.Datastore.query_result_batch_kind">query_result_batch_kind</a></code></li>
<li><code><a title="gcloud.rest.datastore.datastore.Datastore.reserveIds" href="#gcloud.rest.datastore.datastore.Datastore.reserveIds">reserveIds</a></code></li>
<li><code><a title="gcloud.rest.datastore.datastore.Datastore.rollback" href="#gcloud.rest.datastore.datastore.Datastore.rollback">rollback</a></code></li>
<li><code><a title="gcloud.rest.datastore.datastore.Datastore.runQuery" href="#gcloud.rest.datastore.datastore.Datastore.runQuery">runQuery</a></code></li>
<li><code><a title="gcloud.rest.datastore.datastore.Datastore.update" href="#gcloud.rest.datastore.datastore.Datastore.update">update</a></code></li>
<li><code><a title="gcloud.rest.datastore.datastore.Datastore.upsert" href="#gcloud.rest.datastore.datastore.Datastore.upsert">upsert</a></code></li>
<li><code><a title="gcloud.rest.datastore.datastore.Datastore.value_kind" href="#gcloud.rest.datastore.datastore.Datastore.value_kind">value_kind</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>